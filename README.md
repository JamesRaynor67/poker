# poker

### How to run
`python ./main.py`

### Explanation
主要思路是将5张牌的所有情况转化为一个int (cardId)，然后依据德州扑克的规则给每个int一个rankValue表示牌力大小，之后在计算过程中通过穷举+查表相对快速得出结果。
同时，大半代码是为了预先计算csv/zip文件，小部分为UI画图相关，真正的运行时代码较少。
若是不慎删除了csv/zip文件，同样运行main.py文件可以自动生成。但是：
* 生成fiveCardRankList.csv约30分钟，需要约1GB内存。这个文件是主要使用的。
* 生成sevenCardRankList.csv约45分钟，需要约14GB内存。这个文件主要是用于生成下面两个文件，运行时不加载。最后大小为806MB, 所以没有放到github上来。
* 生成twoCardRankValueDistribution.zip约4小时，需要约14GB内存。这个文件是提前计算了我方拿到两张牌后我方/对方最后可能的7张牌中可选的5张牌的最大牌力的大小。
* 生成baselineRankValueDistribution.csv约1分钟。这个文件计算了随机拿7张牌，牌力分布的概率情况。

### Terms
* cardId: 一副牌被映射到0,1,2...51, 那么任意5张牌/7张牌可以被表示为52进制下的一个数，以此用一个int存储5张牌以此进行快速查表等。
* cardRank(牌力): 代表5张牌的大小, 0代表最弱, 2,3,4,5,7小于任何其它牌所以cardRank为0，由于德州扑克不考虑花色，所以有多个cardId的cardRank为0。接下来2,3,4,6,7的cardRank为1。最大的cardRank为同花10,J,Q,K,A的7461。

### Analysis
1. 结果显示总共有7462种不同的牌力(等价类)
2. 1对1的情况下，两张手牌大小相隔更大反而胜率更高(56%左右)。相反，一对A的胜率约47%。这非常反直觉也需要进一步验证。一个可能的解释是手上是一对的情况下限制了牌的可能性。

### Next steps
1. 目前的程序仅适用于1vs1的情况，依照规则德州扑克可以2~9人游戏。需要拓展功能+优化计算考虑不同人数下的影响：
  1. 估计在第一阶段继续计算多人情况下的胜率不显示，或者直接改用蒙特卡洛方法估计+打表即可（牌力的概率分布就去掉吧）
  2. 重点(唯一)需要优化的是第二阶段，1+k个玩家时场上有三张牌的情况下的概率分布计算是1vs1情况下的计算的(C(2+2k,52-5)*C(4,2+2k))/C(4,52-5)倍，k=2时即为903倍。如何优化这一步未知。
  3. 第三阶段，1+k个玩家时场上有三张牌的情况下的概率分布计算是1vs1情况下的计算的(C(1+2k,52-6)*C(3,1+2k))/C(3,52-6)倍
  4. 第三阶段，1+k个玩家时场上有三张牌的情况下的概率分布计算是1vs1情况下的计算的(C(2k,52-7)*C(2,2k))/C(2,52-7)倍
  5. 一个方法是使用sevenCardRankList的打表结果继续优化selectBestFiveOutOfSeven_byLookingUp(sevenCard, fiveCardRankDict)免去内部的21次排列循环+查fiveCardRankList表。但是代价是需要在内存中放一个很大的dict。具体优化结果估计是可以快10倍。
2. 需要进一步验证两张手牌为一对时是否真的胜率反而不足50%，可以通过蒙特卡洛方法简单验证。目前开局仅仅知道手牌为HA,HQ时胜率为45.4%，但是手牌为HA,HJ是胜率为56.5%。需要验证这个结果。
3. 需要考虑如何平衡准确性和实时性，再同时要求两者似乎不太现实。
4. 也许可以考虑如何从1+1个玩家的牌力概率分布估计1+k个玩家的牌力概率分布，但是这样注定不精确，只能认为是一种可选思路。
